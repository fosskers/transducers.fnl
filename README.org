#+title: Transducers: Ergonomic, efficient data processing

#+begin_quote
I think Transducers are a fundamental primitive that decouples critical logic
from list/sequence processing, and if I had to do Clojure all over I would put
them at the bottom.

-- Rich Hickey
#+end_quote

Transducers are an ergonomic and extremely memory-efficient way to process a
data source. Here "data source" could mean an ordinary Table, but also
potentially large files or generators of infinite data.

Transducers...

- allow the chaining of operations like =map= and =filter= without allocating memory between each step.
- aren't tied to any specific data type; they need only be implemented once.
- vastly simplify "data transformation code".
- are a joy to use!

* Table of Contents :toc_2_gh:
- [[#history-and-motivation][History and Motivation]]
- [[#installation][Installation]]
- [[#usage][Usage]]
  - [[#importing][Importing]]
- [[#api][API]]

* History and Motivation

Originally invented in Clojure and adapted to Scheme as SRFI-171, Transducers
are an excellent way to think about - and efficiently operate on - collections
or streams of data. Transduction operations are strict and don't involve
"laziness" or "thunking" in any way, yet only process the exact amount of data
you ask them to.

This library is modelled after [[https://github.com/fosskers/cl-transducers][the Common Lisp implementation]], which was itself
inspired by the original Clojure and SRFI-171.

* Installation

This library consists of only a single module, so it's simple to vendor into
your own projects.

* Usage

** Importing

#+begin_src fennel
(local t (require :transducers))

(t.transduce (t.take 3) t.add [1 2 3 4 5])
#+end_src

#+RESULTS:
: 6

* API

[[file:doc/Transducers.md][See here.]]
